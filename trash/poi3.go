package main

import (
	"fmt"
)

type Point struct {
	x int
	y int
}

func main() {
	var p = &Point{10, 20}
	var P = Point{3, 6}

	// これは、qがpそのものであることを直感的に示している。
	q := p

	// こちらも、(PとQは別物であることを前提に)、QがPそのものを指し示すよう指示しているように見える。
	Q := &P

	// これは、rとpが異なるものであることを直感的に示している。
	r := *p

	// ところが、これが、R !== P であることがわからない。
	R := P

	// つまり、この式でR === Pであるという前提を暗に抱いているといえる。
	// よって、「ポインタを代入しない限り、別物」から考え始めるのが良い。

	// sにはqのポインタを代入するので、s === q であることに疑いはない。
	s := &q

	// これは、p自体を操作しているようにしか見えない。
	(*p).x = 12

	S := *p; S.x = -100 // これをやってもpは一切影響を受けない。

	// これもまた、P自体を操作しているようにしか見えない。
	(&P).x = 45

	r.y = 17 // rにはポインタを取らなかったので、ここでpは影響を受けない。

	fmt.Println(p, q, r, *s) // &{12 20} &{12 20} {10 17} &{12 20}
	fmt.Println(P, Q, R)     // {45 6} &{45 6} {3 6}
}
